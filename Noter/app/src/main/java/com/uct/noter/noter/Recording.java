package com.uct.noter.noter;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Created by Shuaib & Khadeejah on 2016-08-08.
 * Class which will contain all the information about a single recording and its annotations.
 */
public class Recording {

    private List<Annotation> notes;
    private List<Question> questions;
    private List<Theme> themes;
    private List<Float> visualAmplitudes;
    private List<Integer> visualAnnotations, visualThemes;
    private String interviewerName, intervieweeName, date, title;
    private long duration;
    private TimeStamp timeStamp;

    /**
     * Empty constructor for recording
     */
    public Recording() {
    }

    /**
     * Sets recording name, themes and questions
     * @param title name of the recording
     * @param themes list of pre-determined themes
     * @param questions list of pre-determined questions
     */
    public Recording (String title, List<String> themes, List<String> questions) {
        this.title = title;
        createAnnotations(themes, questions);
        this.visualAmplitudes = new ArrayList<Float>();
        this.visualAnnotations = new ArrayList<Integer>();
        this.visualThemes = new ArrayList<Integer>();
    }

    /**
     * Obtain date
     * @return date string
     */
    public String getDate() {
        return date;
    }

    /**
     * Set date to specified date
     * @param date string to assign to date
     */
    public void setDate(String date) {
        this.date = date;
    }

    /**
     * Obtain interviewer name
     * @return interviwerName
     */
    public String getInterviewerName() {
        return this.interviewerName;
    }

    /**
     * Set interviewer name to specified name
     * @param interviewerName specified name
     */
    public void setInterviewerName(String interviewerName) {
        this.interviewerName = interviewerName;
    }

    /**
     * Obtain name of interviewer
     * @return intervieweeName
     */
    public String getIntervieweeName() {
        return intervieweeName;
    }

    /**
     * Set interviewer name to specified name
     * @param intervieweeName specified name
     */
    public void setIntervieweeName(String intervieweeName) {
        this.intervieweeName = intervieweeName;
    }

    /**
     * Set audio track length
     * @param duration length of recording
     */
    public void setDuration(long duration) {
        this.duration = duration;
    }

    /**
     * Obtain length of recording
     * @return duration
     */
    public long getDuration() {
        return this.duration;
    }

    /**
     * Obtain name of recording
     * @return title
     */
    public String getTitle() {
        return title;
    }

    /**
     * Set the name of the recording
     * @param title
     */
    public void setTitle(String title) {
        this.title = title;
    }

    /**
     * Obtain a list of questions
     * @return questions
     */
    public List<Question> getQuestions() {
        return questions;
    }

    /**
     * Set the questions for the recording session
     * @param questions
     */
    public void setQuestions(List<Question> questions) {
        this.questions = questions;
    }

    /**
     * Obtain the themes for recording
     * @return themes
     */
    public List<Theme> getThemes() {
        return themes;
    }

    /**
     * Set the themes for the recording session
     * @param themes
     */
    public void setThemes(List<Theme> themes) {
        this.themes = themes;
    }

    /**
     * Obtain the notes used for this recording session
     * @return notes
     */
    public List<Annotation> getNotes() {
        return this.notes;
    }

    /**
     * Obtain the notes for this recording session
     * @param annotations
     */
    public void setNotes(List<Annotation> annotations) {
        this.notes = annotations;
    }

    /**
     * Obtain the list of amplitudes of the entire recording
     * @return visualAmplitudes
     */
    public List<Float> getVisualAmplitudes() {
        return visualAmplitudes;
    }

    /**
     * Obtain a list of the positions of all the annotations in the recording
     * @return visualAnnotations
     */
    public List<Integer> getVisualAnnotations() { return visualAnnotations; }

    /**
     * Obtain a list of all the themes used in the recording
     * @return visualThemes
     */
    public List<Integer> getVisualThemes() { return visualThemes; }

    /**
     * Set the amplitudes of the recording (Generated by mediaRecorder)
     * @param visualAmplitudes
     */
    public void setVisualAmplitudes(List<Float> visualAmplitudes) {
        this.visualAmplitudes = visualAmplitudes;
    }

    /**
     * Store questions and themes entered by user
     * @param themes list of theme descriptions
     * @param questions list of question descriptions
     */
    private void createAnnotations(List<String> themes, List<String> questions)
    {
        this.questions = new ArrayList<>();
        for (int i = 0; i < questions.size(); i++)
        {
            if (!questions.get(i).equals("")) {
                Question question = new Question(questions.get(i));
                this.questions.add(question);
            }
        }

        this.themes = new ArrayList<>();
        for (int i = 0; i < themes.size(); i++)
        {
            if (!themes.get(i).equals("")) {
                Theme theme = new Theme(themes.get(i));
                this.themes.add(theme);
            }
        }

        this.notes = new ArrayList<Annotation>();
    }

    public void addNote(String description, long time, Date date) {
        this.notes.add(new Annotation(description, time, date.toString()));
    }

    /**
     * Add position of amplitude to recording
     * @param amplitude
     */
    public void addAmplitude(float amplitude) {
        this.visualAmplitudes.add(amplitude);
    }

    /**
     * Add position annotation to recording
     * @param annotation
     */
    public void addVisualizerAnnotation(int annotation) {
        this.visualAnnotations.add(annotation);
    }

    /**
     * Add position of theme to recording
     * @param theme
     */
    public void addVisualTheme(int theme) { this.visualThemes.add(theme); }

    /**
     * Set time that question was annotated at
     * @param description description of theme
     * @param time annotation time
     * @param date annotation date
     */
    public void setQuestionTime(String description, long time, Date date) {
        for (Question question: questions) {
            if (question.getDescription().equals(description)){
                question.setStartTime(time);
                question.setTime(date.toString());
            }
        }
    }

    /**
     *
     * @param description
     * @param time
     * @param date
     */
    public void setThemeStartTime(String description, long time, Date date) {
        for (Theme theme: themes) {
            if (theme.getDescription().equals(description)){
                timeStamp = new TimeStamp(time, date.toString());
            }
        }
    }

    /**
     *
     * @param description
     * @param time
     * @param dateTime
     */
    public void setThemeEndTime(String description, long time, Date dateTime) {
        for (Theme theme: themes) {
            if (theme.getDescription().equals(description)) {
                timeStamp.setEndTime(time);
                theme.addTimeStamp(timeStamp);
            }
        }
    }

    /**
     * method used to shift an annotation backward by 10 seconds
     * @param description
     * @return new start time
     */
    public long shiftAnnotation(String description) {
        for (Question question: questions) {
            if (question.getDescription().equals(description)) {
                question.setStartTime(question.getStartTime()-10000);
                question.setTime(new Date(System.currentTimeMillis()-10000).toString());
                return question.getStartTime();
            }
        }

        for (Annotation note: notes) {
            if (note.getDescription().equals(description)) {
                note.setStartTime(note.getStartTime()-10000);
                return note.getStartTime();
            }
        }
        return -1;
    }

    /**
     * Obtain a question which matches the description
     * @param description
     * @return question
     */
    private Question getQuestion(String description) {
        for (Question question: questions) {
            if (question.getDescription().equals(description))
                    return question;
        }
        return null;
    }

    /**
     * Populates recording with the annotations and themes and populates the list of booleans
     * used to indicate the type of annotations.
     * @param annotations
     * @param type
     */
    public void getPreSetAnnotations(List<String> annotations, List<Boolean> type){

        for (int i = 0; i < this.themes.size(); i++)
        {
            annotations.add(this.themes.get(i).getDescription());
            type.add(true);
        }

        for (int i = 0; i < this.questions.size(); i++)
        {
            annotations.add(this.questions.get(i).getDescription());
            type.add(false);
        }
    }
}
